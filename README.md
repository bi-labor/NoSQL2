# NoSQL BI-Labor
This material is designed to measure the `BMEVIAUMB00` Business Intelligence Laboratory subject with a NoSQL theme.
The laboratory consists of four parts:

1. A brief description of the technologies used.
2. From the preparation of the laboratory environment.
3. From a common implementation of a demonstration application.
4. From solving individual tasks.

During the lab, we will create a simple Chat application to demonstrate the different NoSQL solutions.

## 1. Technology introduction
Our completed application will build on several NoSQL technologies, as well as some parts of the topic of Business Intelligence, 
such as Electron.

NoSQL databases (**N**ot **O**nly **SQL**) are not primarily designed to replace traditional RDBMSs, 
but to cover areas where their use is not optimal (such as performance or complexity issues). due to). 
Therefore, NoSQL databases can also be very different from each other, 
the following main types are distinguished.

- Key-Value based repositories
     * Eg.: REDIS, Apache Accumulo
- Document based
     * Eg.: MongoDB, CouchDB
- Column based
     * Eg.: Cassandra, HBase
- Graph based
     * Eg.: Neo4j, InfiniteGraph
- Object based
     * Eg.: OrientDB

### 1.1. MongoDB
MongoDB enables document-based storage, which is perhaps most similar to the model used for relational databases. 
MongoDB works with the following basic concepts:

#### Document
The basis of data storage is an entity that can be described in a JSON structure. In a relational data model, 
a record can be best matched. In contrast to the relational model, a document is not subject to schema constraints, 
it can have any number and field of fields.

```
{
   field1: value1,
   field2: value2,
   field3: value3,
   ...
   fieldN: valueN
}
```

Each document has a unique identifier stored in the `_id` field, which is basically a field of type 
`ObjectID` generated by the database. Because it also includes a timestamp, it is easy to use 
to sort documents by order of origin.

#### Collection
A common repository for multiple documents is the Collection, a document is always in exactly one collection. 
However, there are no restrictions on how many documents can be in a collection and what kind.

```
{
   firstName: "Béla",
   lastName: "Kovács",
   email: "kovacs@bela.hu",
   favouriteAnimal: "cat"
},
{
   firstName: "Alíz",
   email: "alíz@email.com",
   eyeColor: "Blue"
},
{
   firstName: "Sándor",
   lastName: "Tóth",
   eyeColor: "Blue"
}

```

Collections can be queried, in which case we will return documents that meet the query criteria, 
for example in the collection above:

```
// Query
db.getCollection('myCollection').find({firstName: "Béla"})

// Result
{
   firstName: "Béla",
   lastName: "Kovács",
   email: "kovacs@bela.hu",
   favouriteAnimal: "cat"
}
```
```
// Query
db.getCollection('myCollection').find({eyeColor: "Blue"})

// Result
{
   firstName: "Alíz",
   email: "alíz@email.com",
   eyeColor: "Blue"
},
{
   firstName: "Sándor",
   lastName: "Tóth",
   eyeColor: "Blue"
}
```

### 1.2. Redis
REDIS is an extremely fast, simple key-value pair store that provides a very low response time when working largely in memory. 
At the same time, persistence is also provided with restrictions, 
there is also a snapshot-like state save and a continuous write log-based persistence.

#### Types
REDIS supports several data types, which are displayed in the "field" of the value for that key, for example:

* String
* List
* Set
* Hash
* Bitmap

#### Example commands
At https://try.redis.io you can try out the REDIS command line interface, which also served as the basis for 
most language specific libraries.
Try the following basic REDIS commands on some example data.

In REDIS, we can have several databases represented by a number, the default is database 0.

Select the default database (optional):

```
SELECT 0
```
Insert a value:

```
SET department AUT
```
Query the inserted value:

```
GET department
```
In REDIS, data is first stored in memory, but REDIS also provides persistence / disk backup (by default per second), 
so fast and long-term data storage is also solved.

However, it is possible to store only one piece of data for a specified period of time. 
Use the following command to create a value and set it to be valid for only 10 seconds. 
The TTL command is used to print the remaining validity period:

```
SET department AUT
EXPIRE department 10
TTL department
```
If you still want to persist, use the PERSIST command:
```
PERSIST department
```
In this case, the TTL already returns -1.

```
SUBSCRIBE mychannel
PSUBSCRIBE my\*
PUBLISH mychannel “test message”
```

**Example list operations**

```shell
LPUSH mylist a # (integer) 1
LPUSH mylist b # (integer) 2
LPUSH mylist c # (integer) 3
LRANGE mylist 0 -1 # ”a”, “b”, “c”
LLEN mylist # (integer) 3
DEL mylist # (integer) 1
```

### 1.3. Electron
Electron is a Chromium-based framework that enables the development of cross-platform applications. 
The interface can be created with standard web technologies and then wrapped in the runtime environment 
and presented as a thick client application. A useful addition is that the Developer Tools are available in it, 
if necessary use it for debugging.

## 2. Preparation
**This lab can be done on your own machine (Docker-based or without Docker) or on a virtual machine (without Docker)!**

### 2.1. Environment without Docker

You can also use [Redis](https://redis.io/download)/[Redis on Windows](https://github.com/microsoftarchive/redis/releases/tag/win-3.0.504) and [MongoDB](https://www.mongodb.com/try/download/community) instead of Docker with a traditional installation with custom configuration.

In this case, the port numbers in the `chat-service.js` `connect` function have to also be rewritten to the default or the newer ones in the `mongoose.connect(...)` and `redis.createClient({...})` function calls.) If we have not changed any default settings, then:

```
mongoose.connect('mongodb://' + serverAddress + ':27017/bilabor?authSource=admin', {useNewUrlParser: true, useUnifiedTopology: true})
...

...
redis.createClient({host: serverAddress, port: 6379, retry_strategy: function (){} })
```

Clone or download this repo. Checkout the `eng` branch.

In this case, you will not receive any messages from the lab instructor in any of the chat rooms during the execution. (See docker MongoDB initialization script `mongo-init.js`) If you want, you can add them manually from the command line mongo client, with the MongoDB Compass application or the Robo 3T application.

### 2.2. Docker based environment

During the lab, the two databases will be run as Docker containers using Docker Compose, so they should be available in our environment.

Download and install [Docker Desktop](https://www.docker.com/products/docker-desktop).

Docker is a container-based, small overhead virtualization technology. 
With its help, we can launch Docker containers from Docker Images, which contain a service or software. 
With a few basic commands, you can manage these from the terminal.

* ```docker ps``` - list of running containers
* ```docker exec -it <container name> bash``` - opens a terminal in the given container.
* [More useful commands.](Https://devhints.io/docker)

Clone or download this repo. Checkout the `eng` branch. In the repo folder, you can start the Docker container with the following commands:
```sh
docker-compose -p nosql up -d
```
(Once our work is done, the container can be stopped by `docker-compose -p nosql down`.)

At first startup, the command downloads the required images and then initializes and starts the two services based on the `docker-compose.yml` file. [More details](https://docs.docker.com/compose/compose-file/compose-file-v3/)

You can see that the ports of MongoDB default `27017` and Redis default `6379` are connected to the `57017` and `56379` ports on our own machine.
(To avoid port collisions with possible local instances and previous Docker history.
In the event of a collision, the lines `XXXX:6379` and `YYYY:27017` in the `docker-compose-yml` file have to be rewritten to the desired port and the container should be restarted.

The root user data is set on MongoDB and an initialization script is run. 
The password is set on Redis. 

### 2.3 If you have the environment...

We will use the Node Package Manager to install the dependencies (Electron, Redis and MongoDB drivers, etc.).
Download and install [NPM](https://nodejs.org/en/download/).

In the repo folder, you can download the dependencies based on the contents of the package.json file with the following commands:
```sh
npm install
```
This creates the node_modules folder within the project, which contains the installed dependencies. 
Look at the dependencies object in the `package.json` file and compare it with the contents of the `node_modules` folder.

You can also see from the `package.json` file that when the `npm start` is released, the `electron .` script will run, 
which will display the Electron application (based on `main.js`, it will load the `chat.html` that does not yet exist). Automatic opening of DevTools and support for node integration are also set here.

## 3. The application
The application we create in this lab is a simple chat program. Users can log in, chat with each other in the main room, 
and send private messages to each other. The initial template for the application is provided by this repository.

You can use [WebStorm](https://www.jetbrains.com/webstorm/) or any code editing application to create and edit source files.

### 3.1. User interface
The first step is to render the application, this is done in simple HTML with vanilla JavaScript 
(i.e. we do not use a separate framework) to avoid complications. 
Let’s start by creating the chat user interface itself.

**Task 1.:** Create a `chat.html` file in the root folder of the project with the following content:

```
<!DOCTYPE html>
<html class="fill-vertical" lang="en">
<head>
    <meta charset="UTF-8">
    <title>Chat application</title>

    <!-- Import Bootstrap-->
    <link rel="stylesheet" href="node_modules/bootstrap/dist/css/bootstrap.min.css">
    <link rel="stylesheet" href="node_modules/font-awesome/css/font-awesome.min.css">
    <link rel="stylesheet" href="chat.css">

</head>
<body class="fill-vertical">
<!-- Chat screen -->
<div id="main-window" class="container-fluid p-0 app-window">
    <!-- Navbar -->
    <nav class="navbar navbar-expand navbar-dark bg-dark chat-nav">
        <a class="navbar-brand" href="#">
            <img src="assets/logo.png" width="100" height="36" alt="BME Aut" class="d-inline-block align-top">
            <span class="align-middle">BI NoSQL Labor Chat application</span>
        </a>
    </nav>

    <!-- Chat area -->
    <div class="row chat-body">
        <!-- Users column -->
        <div class="col-md-4">
            <div class="selector-panel">
                <div class="selector-panel-header">
                    <span id="username"></span>
                </div>
                <div class="selector-panel-body">

                    <b>Rooms</b>
                    <ul id="room-list">
                        <li class="selector-panel-item" onclick="chatController.changeRoom('default')">General</li>
                    </ul>

                    <b>Users</b>
                    <ul id="user-list">
                        <!-- Here comes the users list -->
                    </ul>
                </div>
            </div>
        </div>
        <!-- Middle strip (messages + writing message) -->
        <div class="col-md-8 messages-panel">

            <!-- History of messages in the room -->
            <div id="messages-panel" class="row messages-panel-history">
                <div id="messages" class="messages">
                    <!-- Here comes the messages -->
                </div>
            </div>

            <!-- Write new message -->
            <div class="row messages-panel-new">
                <div class="input-group">
                    <textarea id="new-message-text" class="form-control" aria-label="With textarea"></textarea>
                    <div class="input-group-append">
                        <button class="btn btn-success" onclick="chatController.sendMessage()">Send <i
                                class="fa fa-fw fa-send"></i></button>
                    </div>
                </div>
            </div>
        </div>
    </div>
</div>
<script>
  const chatController = require('./chat-controller.js');
  const chatService = require('./chat-service.js');

  window.onbeforeunload = function () {
    chatService.disconnect();
  }
</script>
</body>
</html>
```
Also `chat.css` in the root folder with the following content:

```
/* Remove padding from Bootstrap container (looks nices on desktop) */
.container-fluid{
    overflow: hidden;
    padding-right: 0;
    padding-left: 0;
}

/* Helper class for max. vertical fill */
.fill-vertical {
    height: 100%;
}

.login-window {
    height: 100%;
}

/* Window of the whole chat application */
.app-window {
    display: flex;
    flex-direction: column;
    height: 100%;
}

.chat-nav {
    flex-shrink: 0;
    height: 45px;
}

/* The users, messages and new message part (everything below the header) */
.chat-body {
    flex-grow: 1;
}

.selector-panel {
    background-color: darkgray;
    height: 100%;
}

.selector-panel-header {
    text-align: center;
    font-weight: bold;
    padding-top: 8px;
    padding-bottom: 8px;
}

.selector-panel-body {
    background-color: lightgray;
    height: 100%;
    padding: 8px;
    overflow-y: auto;
}

.selector-panel-item:hover {
    text-decoration: underline;
    cursor: pointer;
}

.messages-panel {
    display: flex;
    flex-direction: column;
    padding-left: 0;
    padding-top: 8px;
}

.messages-panel-history {
    flex-grow: 3;
    height: 100%;
    padding-left: 23px;
    padding-right: 23px;
    overflow-y: scroll;
}

.messages {
    width: 100%;
}

.message-avatar {
    border-width: 1px;
    border-style: solid;
    border-color: lightgray;
}

.messages-panel-new {
    flex-grow: 1;
    margin: 8px;
}

.messages-new-input {
    width: 100px;
}

textarea {
    resize: none;
}
```

After `npm start` command, the following window will appear if you have done everything right.

![Task 1.](readme_images/task1.png)

**Task 2.:** Let's build our application further by implementing the user interface and business logic! 
To do this, we first add a new step to our interface, the login screen. To do this, add the following snippet of code 
directly under the `chat.html` `<body>` tag:

```
<!-- Login screen -->
<div id="login-window" class="container login-window">
    <div class="jumbotron">
        <h1>BI Laboratory NoSQL Chat application</h1>
        <p>Welcome to the Chat application of BI Laboratory course, demonstrating the functions of NoSQL databases 
            and giving an introduction into Electron.</p>
    </div>
    <div class="input-group mb-3">
        <div class="input-group-prepend">
            <span class="input-group-text"><i class="fa fa-fw fa-user"></i></span>
        </div>
        <input id="usernameInput" type="text" class="form-control" placeholder="Username">
    </div>
    <div class="input-group mb-3">
        <div class="input-group-prepend">
            <span class="input-group-text"><i class="fa fa-fw fa-server"></i></span>
        </div>
        <input id="serverInput" type="text" class="form-control" placeholder="Server IP">
    </div>
    <div class="input-group mb-3">
        <div class="input-group-prepend">
            <span class="input-group-text"><i class="fa fa-fw fa-key"></i></span>
        </div>
        <input id="passwordInput" type="text" class="form-control" placeholder="Server password">
    </div>
    <div class="text-center">
        <button class="btn btn-primary" onclick="chatController.login()"><i class="fa fa-fw fa-sign-in"></i>Login
        </button>
    </div>
</div>
```

Hide the chat screen with a `style ="display: none"` attribute, i.e. add it to the div with the `main-window` ID, 
something like this:

```
...
<!-- Chat screen -->
<div id="main-window" class="container-fluid p-0 app-window" style="display:none">
...
```
We can now create a `chat-controller.js` file describing the interface logic with the following content:
```
const chatService = require('./chat-service.js');
const _ = require('lodash');

const chatController = {};

// Initialize the settings
let selectedRoom = 'default';
let myUsername = '';

// Called at login and inicializes the default room
chatController.login = function () {
  let usernameInput = document.getElementById('usernameInput');
  let serverInput = document.getElementById('serverInput');
  let passwordInput = document.getElementById('passwordInput');


  if (_.isEmpty(usernameInput.value) || _.isEmpty(serverInput.value)) {
    alert('Please provide every data!');
  } else {
    myUsername = _.escape(usernameInput.value);
    chatService.connect(usernameInput.value, serverInput.value, passwordInput.value, function () {
        // Connection successful
        // Swich screen (poorman’s SPA)
        document.getElementById('login-window').style.display = 'none';
        document.getElementById('main-window').style.display = 'flex';

        // Print the logged in username
        document.getElementById('username').innerText = myUsername;
        chatController.refreshUsers();
        chatController.refreshRoom();
      },
      function (err) {
        alert("Could not connect to the database: " + err)
      },
      // New message received somewhere (event on roomsChannel)
      function (roomName) {
        if (roomName === selectedRoom) {
          chatController.refreshRoom();
        }
      },
      // User number changed
      function () {
        chatController.refreshUsers();
      });
  }
};

// Print a new message at message history
chatController.renderNewMessage = function (message) {
  // Fing the messages history area in the DOM with ID "messages", it is an unnumbered list (<ul>).
  let messageArea = document.getElementById('messages');

  // Fill and add a new message based ont he HTML template
  messageArea.insertAdjacentHTML('beforeEnd',
    '<div class="media messages">' +
    '<img src="assets/user.png" width="40" height="40" class="mr-3 message-avatar">' +
    '<div class="media-body">' +
    '<h5 class="mt-0">' + _.escape(message.user) + '</h5>' + _.escape(message.content) +
    '</div>' +
    '</div>' +
    '<hr>'
  );

  // Scroll down to the bottom of the history
  document.getElementById('messages-panel').scrollTo(0, messageArea.scrollHeight);
};

// Prints a username on users list
chatController.renderNewUser = function (user) {
  let userList = document.getElementById('user-list');
  let listedUser = _.escape(user);

  // Name a private room between two users. The order is important due to two-way communication. 
  let keys = _.orderBy([myUsername, listedUser]);
  let privateRoomName = keys[0] + '_' + keys[1];

  if (selectedRoom === privateRoomName) {
    // If we already there, no link is necessary.
    userList.insertAdjacentHTML('beforeEnd', '<li class="selector-panel-item selected"><b>' + listedUser + '</b></li>');
  } else {
    userList.insertAdjacentHTML('beforeEnd', '<li class="selector-panel-item" onclick="chatController.changeRoom(\'' + privateRoomName + '\')">' + listedUser + '</li>');
  }
};

// Send a new message with our username
chatController.sendMessage = function () {
  let textInput = document.getElementById('new-message-text');
  if (!_.isEmpty(textInput.value)) {
    let message = {
      user: myUsername,
      content: textInput.value,
      date: new Date()
    };
    chatController.renderNewMessage(message);
    chatService.sendMessage(selectedRoom, message);
  }
  textInput.value = '';
};

// Switching room
chatController.changeRoom = function (roomName) {
  selectedRoom = roomName;
  chatController.refreshRoom();
  chatController.refreshUsers();
};

// Updating the messages in room
chatController.refreshRoom = function () {
  document.getElementById('messages').innerHTML = '';
  // Load the messages history
  chatService.getMessages(selectedRoom, function (messages) {
    _.forEach(messages, function (message) {
      chatController.renderNewMessage(message);
    })
  });
};

// Update the users list content
chatController.refreshUsers = function () {
  document.getElementById('user-list').innerHTML = '';
  // Load the users (without self)
  chatService.getUsers(function (users) {
    _.forEach(users, function (user) {
      if (myUsername !== user) {
        chatController.renderNewUser(user);
      }
    });
  });
};

module.exports = chatController;
```
After a thorough examination of the code, learning about the functions of each function, we can see that the chat logic itself is not
implemented in this file. The source of messages and logged in users is `chat-service.js`, so
we also create it for now with the following mock content:

```
let _ = require('lodash');

const chatService = {};

// Our username
let myUsername;
let messages = {
  default: [
    {
      user: "Test John",
      date: new Date(),
      content: "This is a test message from John into the general room."
    },
    {
      user: "Test Jane",
      date: new Date(),
      content: "Hi John!"
    },
  ]
};

// Function called when connecting
chatService.connect = function (username, serverAddress, password, successCb, failCb, messageCallback, userCallback) {
  myUsername = username;
  successCb();
};

// Disconnect from server
chatService.disconnect = function () {

};

// Returns the messages in the room
chatService.getMessages = function (roomId, cb) {
  cb(messages[roomId]);
};

// Returns the logged in users list
chatService.getUsers = function (cb) {
  cb([
    "John",
    "Jane"
  ])
};

// Send message
chatService.sendMessage = function (roomId, message) {
  (messages[roomId] = messages[roomId] || []).push({
    user: myUsername,
    date: message.date,
    content: message.content
  });

};

module.exports = chatService;

```

If we did well, by restarting our chat application is already working, we can message them by clicking on the names of each user.
At this point, you do not need a password to log in, you can enter anything for the server's IP, just don't leave it blank (due to validation).

    Document the individual tasks as instructed in the report template.

![Task 2.](readme_images/task2.png)

### 3.2. Database
Now that we have a working application framework, we start with the laboratory's substantive, NoSQL part! As a first task
we persist the messages in MongoDB. For this we figured out the following data model:

```
Message:
{
    user: <String – The username>
    date: <Date – When the message sent>
    content: <String – Message content>
    room: <String – The room name where the message was sent to>
}
```

A message will be stored in a `document` with such properties, these messages will be in a` collection`. 
We will use a library called mongoose for easier database communication. Modify the `chat-service.js` file as follows:

* Delete the `let messages = {...}` declaration (since this is just a mock).
* Import mongoose by placing the following command at the beginning of the file: `let mongoose = require ('mongoose');`
* Modify the `chatService.connect` function to the following to actually connect to the database:
```
// Function called when connecting
chatService.connect = function (username, serverAddress, password, successCb, failCb, messageCallback, userCallback) {
  myUsername = username;
  mongoose.connect('mongodb://bilabor:' + password + '@' + serverAddress + ':57017/bilabor?authSource=admin', {useNewUrlParser: true, useUnifiedTopology: true}).then(function () {
    successCb();
  }, failCb);
};
```
* Define the message model for mongoose by adding the following declaration above `chatService.connect` line:
```
// Description of message model
const Message = mongoose.model('Message', new mongoose.Schema({
  user: String,
  date: Date,
  content: String,
  room: String
}));
```
* Also rewrite the `chatService.getMessages` function to call the database:
```
// Returns the messages in the room
chatService.getMessages = function (roomId, cb) {
  Message.find({room: roomId}, function (err, msg) {
    cb(msg)
  });
};
```
* Rewrite the `chatService.sendMessage` function to write the message to the database.
```
// Send message
chatService.sendMessage = function (roomId, message) {
  let msg = new Message({
    user: myUsername,
    date: message.date,
    content: message.content,
    room: roomId
  });
  msg.save();
};
```
We are ready with this, our messages are now stored in the common MongoDB database, we can message each other, but the
messages do not appear by themselves, only for manual update.

**Using Docker, server IP: localhost, password: bilabor**

    Document the individual tasks as instructed in the report template.

### 3.3. Real-time communication
It is not advisable to store the list of currently online users in a database, as it can change frequently,
may need to be constantly updated and is not business data. That is why in our application use REDIS that
we will solve it with a key-value store. This will have two tasks:

* Store a list of current users.
* Notify subscribers if this changes.

The second task will be implemented using the REDIS Publish-Subscribe model, which allows creating `channels`
to which events can be submitted and clients can subscribe to observe.

So in summary:
* We will have a `SortedSet` in which users will be, on a "self-declaration" basis.
* There will be a `users_channel` where we send a message when a user logs in or out (message content
irrelevant).
* There will be a `rooms_channel` where we send a message when a new message arrives in a room, the message
contents of the room name.

It is important that the redis client version used during the lab uses a slightly different syntax compared to the latest version.

Let's start the implementation by importing the redis client and storing the names of each channel, do the following
to the beginning of the `chat-service.js` file (for example, under mongoose import):
```
let redis = require('redis');

const roomsChannel = 'rooms_channel';
const usersChannel = 'users_channel';
let redisClient;
let redisSubscriberClient;
```
After that we need to update the `chatService.connect` function, rewrite it as follows:

```
// Function called when connecting
chatService.connect = function (username, serverAddress, password, successCb, failCb, messageCallback, userCallback) {
  myUsername = username;
  let dbReady = false;
  let mqReady = false;

  let db = mongoose.connect('mongodb://bilabor:' + password + '@' + serverAddress + ':57017/bilabor?authSource=admin', {useNewUrlParser: true, useUnifiedTopology: true});
  redisClient = redis.createClient({
    host: serverAddress, port: 56379, password: password, retry_strategy: function () {
    }
  });

  // If all connection is successfull
  function connectionSuccesfull() {
    // Adding self to the users list
    redisClient.zadd(usersChannel, 0, username);
    // Notify about our login
    redisClient.publish(usersChannel, username);

    // Subscribing to important events
    // Separate clint is necessary for subscription, duplicate the original
    redisSubscriberClient = redisClient.duplicate();
    redisSubscriberClient.subscribe(roomsChannel);
    redisSubscriberClient.subscribe(usersChannel);
    redisSubscriberClient.on('message', function (channel, message) {
      if (channel === roomsChannel) {
        // New message to roomsChannel means the message history should be updated in a room
        messageCallback(message);
      } else if (channel === usersChannel) {
        // New message to usersChannel means the users list changed
        userCallback();
      }
    });

    successCb();
  }

  // We dont know which callback is called first, so we will call back after the second 
  db.then(function () {
    dbReady = true;
    if (mqReady === true) {
      connectionSuccesfull();
    }
  }, failCb);

  // Redis client events
  redisClient.on('ready', function () {
    mqReady = true;
    if (dbReady === true) {
      // If MongoDB is connected, login
      connectionSuccesfull();
    }
  });
  redisClient.on('error', failCb);
};
```
This is a slightly more complex snippet of code, the point is to subscribe to the specified channels after database and redis connections created. 
As a result of the incoming events, we call the corresponding callback methods of the `chat-controller`,
which will update interface.

We also implement the `chatService.disconnect` function (i.e. tell REDIS if you close the app).
```
// Disconnect from server
chatService.disconnect = function () {
  if (!_.isUndefined(redisClient)) {
    redisClient.zrem(usersChannel, myUsername);
    redisClient.publish(usersChannel, myUsername);
  }
};
```
Also override `chatService.getUsers` function to retrieve data from REDIS, using the ZRANGE function.
```
// Returns the logged in users list
chatService.getUsers = function (cb) {
  redisClient.zrange(usersChannel, 0, -1, function (error, result) {
    cb(result);
  });
};
```
Finally, complete the `chatService.sendMessage` function to notify about the change if the database is saved successfully:
```
// Send message
chatService.sendMessage = function (roomId, message) {
  let msg = new Message({
    user: myUsername,
    date: message.date,
    content: message.content,
    room: roomId
  });
  msg.save().then(function () {
    // Notify about updating messages in room
    redisClient.publish(roomsChannel, roomId)
  })
};
```

    Document the individual tasks as instructed in the report template.

We ended up with the common tasks! The rest of the laboratory is doing individual tasks.


## 4. Individual tasks

    Document the individual tasks as instructed in the report template.

Finishing the previous parts is the minimum for mark 2, the solution of the 3 individual problems means each +1 grade, ie:
* Guided part + 1 solved individual task = 3
* Guided part + 2 solved individual tasks = 4
* Guided part + all solved individual tasks = 5

### 4.1. Avatars
Allow the user to enter their own avatar URL, which is stored in the database in the `Messages` collection, 
in each document under the `avatarUrl` field. 

**Tip**: Use an online avatar generator, such as https://getavataaars.com. You do not need to host the file in this case. 

![Task 3.](readme_images/task3.png)

### 4.2. Rooms
The chat program can handle any number of rooms, but currently only the `default` exists, and each private message room
is created in the background. Make sure the application takes the list of rooms from the MongoDB `rooms` collection at startup 
(the collection is named with the plural by Mongoose, which is enough to call the model `Room`). 
There are documents in this collection that have one attribute, the `name`, which specifies the name of the room. 
**It is not part of this task to create the room or monitor the change!** 
To facilitate testing, we have already created a few examples in the database.

![Task 4.](readme_images/task4.png)

### 4.3. Observing room changes
Add to the previous function that the application monitors the REDIS `roomlist_channel`, 
updating the room list as a result of events coming here. You can add any room for testing, either programmatically 
(for example, by adding the `connect` function to create a new room after a successful connection) 
or by using the buttons on the interface (but this is optional, it's not an HTML / CSS lab). 

![Task 5.](readme_images/task5.png)

